--- introduction

<h3>your first pugl</h3>
<p>
when you load up pugl for the first time, you should be greeted with a â€œBufferâ€ widget.
try changing its â€œinputâ€ value to <code>.pos.x</code>.
<div>
	<img src="ex-posx.png" alt="">
</div>
you should see a nice gradient like this: <span style="display:inline-block;margin-right:1em;width:2em;height:1em;background-image:linear-gradient(90deg, #000,#000,#000,#fff);"></span>
here the color of each pixel is directly determined by its x coordinate.
specifically: <code>.pos.x</code> is âˆ’1 at the left side of the screen and +1 at the right side of the screen.
since the â€œBufferâ€ widgetâ€™s title is in <span style="color:yellow;font-weight:bold;">yellow</span>,
the pixel values will be drawn from it. 0 (or anything below 0) is black and 1 (or anything above 1) is white,
so we see a gradient from black to white starting from the center of the screen.
</p>
<p>
now letâ€™s try something a little more interesting. try adding a â€œMultiplyâ€ widget (by searching for it or
selecting it from the â€œmathâ€ section). set the â€œaâ€ input to <code>.pos.x</code> and the â€œbâ€ input to
<code>.pos.y</code>. then click on the â€œMultiplyâ€ text to set it as the active widget.
<div>
	<img src="ex-multiply.png" alt="">
</div>
you should now see a more interesting pattern where two of the corners of the screen are
white, and the other two corners are black: <img src="output-multiply.png" style="height:1em;" alt="">
</p>

<h3>vectors</h3>

<p>
well, black &amp; white is pretty boring. letâ€™s try making some colors!
one of the nice things about shaders is that theyâ€™re very good at dealing with <a href="https://en.wikipedia.org/wiki/Vector_%28mathematics_and_physics%29" target="_blank">vectors</a>.
thereâ€™s a lot of mathematical theory behind vectors, but for our purposes all that really matters is that a vector is a list of numbers (called <em>components</em>).
in shaders you basically only deal with vectors with 2 to 4 components (referred to as x, y, z, w).
in graphics programming, colors are represented as vectors with 3 components, <span style="color:#f00;">red</span>,
<span style="color:#0f0;">green</span>, and <span style="color:#22f;">blue</span>, which go from 0 to 1.
try putting <code>0,0.8,1</code> in a â€œBufferâ€ widget and making it active.
now the widget is outputting a 3D vector with x=0, y=0.8, and z=1, so
youâ€™ll get a nice <span style="color:#0cf">greenish blue</span> color!
</p>

<p>
<code>.pos</code> is itself a vector, so you can just throw it into the Buffer input:
<div><img src="ex-vector.png" alt=""> <img src="output-vector.png" alt="" height="32"></div>
notice how the output is red on the right side of the screen (where the x component of <code>.pos</code> is high)
and green at the top of the screen (where the y component of <code>.pos</code> is high).
</p>

<p>
most widgets like Multiply work on both numbers and vectors. try multiplying together
<code>.pos</code> and <code>.pos.x</code>:
<div><img src="ex-multiply-vector.png" alt=""> <img src="output-multiply-vector.png" alt="" height="32"></div>
this multiplies each of the components of <code>.pos</code> by <code>.pos.x</code>.
so the top-left corner is red, because (âˆ’1, 1) Ã— âˆ’1 = (1, âˆ’1), so the top-left pixel gets a red value of 1 and a green value of âˆ’1.
</p>

<h3>multiple widgets</h3>

<p>
you can use the output of one widget to specify the input of another widget using its name.
try creating an â€œAddâ€ widget with inputs <code>mul1,0</code> and <code>0,0,.pos.x</code> (assuming
your Multiply widget from the last section was called mul1).
<div><img src="ex-multiply-add.png" alt=""> <img src="output-multiply-add.png" alt="" height="32"></div>
now the left side looks the same as before, but the right side (where <code>.pos.x</code> is 1) is bluer!
</p>

<h3>putting everything together</h3>

<p>
alright let's use all this to make something cool.
we'll start by making a rainbow.
the â€œHue shiftâ€ widget shifts the hue of a color through the rainbow.
so if we start with a color of red, and shift it by <code>.pos.x</code>,
we'll get a rainbow across the screen:
<div>
<img src="ex-hue-shift.png" alt=""> <img src="output-hue-shift.png" alt="" height="32">
</div>
</p>

<p>
now let's animate this rainbow: create a new â€œAddâ€ widget,
and set a=<code>.pos.x</code>, b=<code>.time</code>,
and use that as the shift instead of <code>.pos.x</code>:
<div><img src="ex-hue-shift-time.png" alt=""></div>
now the rainbow moves across the screen over time!
</p>

<p>
next weâ€™ll use the widget that makes pugl unique â˜º
â€œLast frameâ€. this lets you grab pixel values from the previous frame
to use in the current frame. add a â€œLast frameâ€ widget,
and set it as the active widget. notice how the rainbow freezes in place â€”
thatâ€™s because each pixel value is just being determined by what it was 
on the last frame.
<div><img src="ex-last-frame.png" alt=""></div>
</p>
<p>
now add a â€œWeighted sumâ€ widget, set â€œa weightâ€ to 0.95, â€œb weightâ€ to 0.05,
â€aâ€ to your last frame widget's output, and â€œbâ€ to the hue shift's output.
this will output a value which is 95% like the previous frame's value,
and 5% like the shifting rainbow.
<div><img src="ex-weighted-sum.png" alt=""></div>
try switching between the â€œHue shiftâ€ and â€œWeighted sumâ€ widgets
and note how the weighted sum is blurrier, because it's averaging
with the previous pixel value.
</p>
<p>
now, we donâ€™t have to use <code>.pos</code> as the position for getting
pixel values from the last frame. instead, letâ€™s rotate <code>.pos</code>
by a small amount and use that as the position for the â€œLast frameâ€ widget:
<div><img src="ex-rotate-2d.png" alt=""> <img src="output-rotate-2d.png" alt=""></div>
now weâ€™re getting something interesting!
</p>

<p>
be sure to check out the rest of this guide to learn all the things
you can do with pugl. have fun! ğŸ±
</p>
